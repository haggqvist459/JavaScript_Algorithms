/*
Algorithm Design Techniques: 


Brute force:
Simple and exhaustive technique that evaluates every possible outcome to find the best solution: 
For example: linear search

Greedy: 
Choose the best option at the current time without any consideration for the future.
For example: Dijkstra's algorithm, Prim's algorithm and Kruskal's algorithm

Divide and conquer: 
Divie the problem into smaller sub-problems. Each sub-problem is then solved and the partial solutions are recombined to determine the overall solution. 
For example, binary search, quick sort, merge sort and Tower of Hanoi.

Dynamic programming: 
Divide the problem into smaller sub-problems. Break it down into smaller but overlapping sub-problems. Store the result and reuse it for the same sub-problems.
This is called memoisation and is an optimisation technique that improves the time complexity of your algorithm. 
For example, fibonacci numbers and climbing staircase 

Backtracking: 
Generate all possible solutions. Check if hte solution satisfies the given constrains and only then do you proceed with generating subsequent solutions. 
If the constrains are not satisfied, backtrack and go on a different path to find the solution.
For example: N-Queens problem.


Next Steps: 

    - Finding the greatest common diviser using Euclidian algorithm 
    - Finding permutations and combinations of a list of numbers
    - Finding the longest common substring in a given string
    - Knapsack problem 

*/

